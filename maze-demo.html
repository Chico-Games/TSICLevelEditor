<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Algorithms Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
        }
        .section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
            margin-right: 10px;
        }
        button:hover {
            background: #45a049;
        }
        canvas {
            border: 2px solid #333;
            display: block;
            margin: 20px auto;
            background: white;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-box {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }
        .stat-label {
            font-weight: bold;
            color: #666;
            font-size: 14px;
        }
        .stat-value {
            font-size: 24px;
            color: #333;
            margin-top: 5px;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 30px;
            height: 30px;
            border: 1px solid #333;
        }
        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>Maze Algorithms Demo</h1>
    <p>Demonstration of FloodFillEngine and MazeGenerator classes from maze-algorithms.js</p>

    <div class="section">
        <h2>Demo: Vertical Wall with Maze Generation</h2>
        <div class="controls">
            <button onclick="runDemo()">Generate New Maze</button>
            <button onclick="toggleView()">Toggle View</button>
        </div>

        <canvas id="mazeCanvas" width="600" height="600"></canvas>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #333;"></div>
                <span>Blocked Border</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b;"></div>
                <span>Region A</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4ecdc4;"></div>
                <span>Region B</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #45b7d1;"></div>
                <span>Maze Connections</span>
            </div>
        </div>

        <div class="stats" id="stats"></div>
    </div>

    <div class="section">
        <h2>Technical Details</h2>
        <h3>Coordinate System</h3>
        <ul>
            <li><strong>Top-down:</strong> Y=0 at TOP, Y increases DOWNWARD</li>
            <li><strong>Index formula:</strong> Index = Y Ã— WorldWidth + X</li>
            <li><strong>North:</strong> Index - WorldWidth (toward smaller Y)</li>
            <li><strong>South:</strong> Index + WorldWidth (toward larger Y)</li>
            <li><strong>East:</strong> Index + 1 (toward larger X)</li>
            <li><strong>West:</strong> Index - 1 (toward smaller X)</li>
        </ul>

        <h3>Direction Encoding (4-bit)</h3>
        <ul>
            <li><strong>Bit 0 (value 1):</strong> North (Up)</li>
            <li><strong>Bit 1 (value 2):</strong> South (Down)</li>
            <li><strong>Bit 2 (value 4):</strong> East (Right)</li>
            <li><strong>Bit 3 (value 8):</strong> West (Left)</li>
        </ul>

        <h3>Example Usage</h3>
        <pre>// 1. Create FloodFillEngine
const floodFill = new MazeAlgorithms.FloodFillEngine();

// 2. Prepare data
const heightMap = new Uint8Array(100); // 10x10 grid
const biomeMap = new Array(100);
const settings = {
    borderBiomes: new Set(['Blocked']),
    maxHeightDiff: 1
};

// 3. Perform flood fill
const result = floodFill.performFloodFill(
    heightMap, biomeMap, settings, 10
);

// 4. Generate mazes for each region
const mazeGen = new MazeAlgorithms.MazeGenerator();
const worldMazeData = new Uint8Array(100);

for (const region of result.regions) {
    const seed = 12345 + region.tileIndices[0];
    const mazeData = mazeGen.generateMaze(
        region.tileIndices, 10, seed
    );

    // Apply to world
    for (const idx of region.tileIndices) {
        worldMazeData[idx] = mazeData[idx];
    }
}</pre>
    </div>

    <script src="js/maze-algorithms.js"></script>
    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');

        const GRID_SIZE = 20;
        const TILE_SIZE = canvas.width / GRID_SIZE;

        let currentData = null;
        let viewMode = 'regions'; // 'regions' or 'maze'

        function runDemo() {
            // Create 20x20 grid with vertical wall at X=10
            const totalTiles = GRID_SIZE * GRID_SIZE;
            const heightMap = new Uint8Array(totalTiles);
            heightMap.fill(5);

            const biomeMap = new Array(totalTiles);
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const index = y * GRID_SIZE + x;
                    if (x === 10) {
                        biomeMap[index] = 'Blocked';
                    } else {
                        biomeMap[index] = 'ShowFloor';
                    }
                }
            }

            // Flood fill
            const floodFill = new MazeAlgorithms.FloodFillEngine();
            const settings = {
                borderBiomes: new Set(['Blocked']),
                maxHeightDiff: 1
            };

            const floodResult = floodFill.performFloodFill(
                heightMap, biomeMap, settings, GRID_SIZE
            );

            // Generate mazes
            const mazeGen = new MazeAlgorithms.MazeGenerator();
            const worldMazeData = new Uint8Array(totalTiles);

            const seed = Date.now(); // Random seed based on time
            for (let i = 0; i < floodResult.regions.length; i++) {
                const region = floodResult.regions[i];
                const regionSeed = seed + region.tileIndices[0];
                const mazeData = mazeGen.generateMaze(
                    region.tileIndices, GRID_SIZE, regionSeed
                );

                for (const idx of region.tileIndices) {
                    worldMazeData[idx] = mazeData[idx];
                }
            }

            // Store data
            currentData = {
                biomeMap,
                floodResult,
                worldMazeData
            };

            // Update stats
            updateStats(floodResult);

            // Draw
            draw();
        }

        function toggleView() {
            viewMode = viewMode === 'regions' ? 'maze' : 'regions';
            draw();
        }

        function updateStats(result) {
            const statsHtml = `
                <div class="stat-box">
                    <div class="stat-label">Total Regions</div>
                    <div class="stat-value">${result.regions.length}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Tiles in Regions</div>
                    <div class="stat-value">${result.tilesInRegions}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Border Tiles</div>
                    <div class="stat-value">${result.borderTiles}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Largest Region</div>
                    <div class="stat-value">${result.largestRegionSize} tiles</div>
                </div>
            `;
            document.getElementById('stats').innerHTML = statsHtml;
        }

        function draw() {
            if (!currentData) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (viewMode === 'regions') {
                drawRegions();
            } else {
                drawMaze();
            }
        }

        function drawRegions() {
            const { biomeMap, floodResult } = currentData;
            const colors = ['#ff6b6b', '#4ecdc4', '#95e1d3', '#f38181', '#aa96da'];

            // Draw regions
            for (let i = 0; i < floodResult.regions.length; i++) {
                const region = floodResult.regions[i];
                const color = colors[i % colors.length];

                ctx.fillStyle = color;
                for (const idx of region.tileIndices) {
                    const x = idx % GRID_SIZE;
                    const y = Math.floor(idx / GRID_SIZE);
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // Draw blocked tiles
            ctx.fillStyle = '#333';
            for (let i = 0; i < biomeMap.length; i++) {
                if (biomeMap[i] === 'Blocked') {
                    const x = i % GRID_SIZE;
                    const y = Math.floor(i / GRID_SIZE);
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // Draw grid
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * TILE_SIZE, 0);
                ctx.lineTo(i * TILE_SIZE, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * TILE_SIZE);
                ctx.lineTo(canvas.width, i * TILE_SIZE);
                ctx.stroke();
            }
        }

        function drawMaze() {
            const { biomeMap, worldMazeData, floodResult } = currentData;

            // Draw background
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw blocked tiles
            ctx.fillStyle = '#333';
            for (let i = 0; i < biomeMap.length; i++) {
                if (biomeMap[i] === 'Blocked') {
                    const x = i % GRID_SIZE;
                    const y = Math.floor(i / GRID_SIZE);
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // Draw maze connections
            ctx.strokeStyle = '#45b7d1';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';

            for (const region of floodResult.regions) {
                for (const idx of region.tileIndices) {
                    const x = idx % GRID_SIZE;
                    const y = Math.floor(idx / GRID_SIZE);
                    const cx = (x + 0.5) * TILE_SIZE;
                    const cy = (y + 0.5) * TILE_SIZE;

                    const directions = worldMazeData[idx];

                    // Draw connections
                    if (directions & 1) { // North
                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(cx, cy - TILE_SIZE * 0.4);
                        ctx.stroke();
                    }
                    if (directions & 2) { // South
                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(cx, cy + TILE_SIZE * 0.4);
                        ctx.stroke();
                    }
                    if (directions & 4) { // East
                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(cx + TILE_SIZE * 0.4, cy);
                        ctx.stroke();
                    }
                    if (directions & 8) { // West
                        ctx.beginPath();
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(cx - TILE_SIZE * 0.4, cy);
                        ctx.stroke();
                    }

                    // Draw center dot
                    ctx.fillStyle = '#45b7d1';
                    ctx.beginPath();
                    ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Run demo on load
        runDemo();
    </script>
</body>
</html>
