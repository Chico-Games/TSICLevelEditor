# TSIC Level Editor - JSON Format Guide

## Overview
This guide explains how to read and parse the JSON export format from the TSIC Level Editor. The format uses Run-Length Encoding (RLE) with color palettes for compact storage of world data.

**IMPORTANT:** As of version 1.0, exported JSON files are **self-documenting** and include all color mappings and instructions. You don't need this external guide to read the files - everything you need is embedded in the JSON!

---

## JSON Structure

The exported JSON has 4 main sections:

```json
{
  "metadata": {
    "name": "ProjectName",
    "description": "Generated by TSIC Level Editor",
    "world_size": 256,
    "maze_generation_seed": 1234567890
  },
  "layers": [
    {
      "layer_type": "Height",
      "palette": ["#0a0a0a", "#525d6b", "#ffffff"],
      "color_data": [[0, 1000], [1, 500], [2, 250]]
    }
    // ... more layers
  ],
  "color_mappings": {
    "biomes": { "#color": { "value": 0, "name": "...", "description": "..." } },
    "heights": { "#color": { "value": 0, "name": "...", "description": "..." } },
    "difficulty": { "#color": { "value": 0, "name": "...", "description": "..." } },
    "hazards": { "#color": { "value": 0, "name": "...", "description": "..." } }
  },
  "format_info": {
    "description": "JSON-RLE format description",
    "version": "1.0",
    "how_to_read": {
      "step_1": "Instructions...",
      "step_2": "More instructions...",
      // ... etc
    }
  }
}
```

See `EXAMPLE_EXPORT.json` in the project folder for a complete example with all mappings.

---

## Metadata Section

| Field | Type | Description |
|-------|------|-------------|
| `name` | string | Project/level name |
| `description` | string | Level description |
| `world_size` | integer | Grid dimensions (always square: world_size × world_size) |
| `maze_generation_seed` | integer | Optional random seed used for generation |

**Example:**
```json
"metadata": {
  "name": "TestStore",
  "description": "Generated by TSIC Level Editor",
  "world_size": 256,
  "maze_generation_seed": 1762348446922
}
```
This means the level is a **256×256 grid** (65,536 total tiles).

---

## Color Mappings Section (NEW in v1.0)

The `color_mappings` section contains all the color-to-enum conversions you need:

```json
"color_mappings": {
  "biomes": {
    "#ff6b6b": {
      "value": 1,
      "name": "Biome_ShowFloor",
      "description": "Store showroom floor"
    }
    // ... 22 more biome mappings
  },
  "heights": {
    "#0a0a0a": {
      "value": 0,
      "name": "Height_Underground_Deep",
      "description": "Deep underground"
    }
    // ... 9 more height mappings (0-9 total)
  },
  "difficulty": { /* 5 mappings: 0-4 */ },
  "hazards": { /* 3 mappings: 0-2 */ }
}
```

**Usage:** Look up a color in the appropriate category to get its enum value. For example:
- Height layer with color `#0a0a0a` → look in `color_mappings.heights["#0a0a0a"]` → value = 0
- Floor layer with color `#ff6b6b` → look in `color_mappings.biomes["#ff6b6b"]` → value = 1

---

## Format Info Section (NEW in v1.0)

The `format_info` section provides step-by-step instructions on how to read the file:

```json
"format_info": {
  "description": "JSON-RLE (Run-Length Encoding) format for TSIC world generation",
  "version": "1.0",
  "how_to_read": {
    "step_1": "Each layer has a 'palette' (array of colors) and 'color_data' (RLE compressed data)",
    "step_2": "RLE format: [[paletteIndex, count], ...] where paletteIndex references palette array",
    "step_3": "Decompress: for each [index, count], repeat palette[index] for count tiles",
    "step_4": "Tiles are stored in row-major order: index = y * world_size + x",
    "step_5": "Use color_mappings below to convert colors to enum values for each layer type"
  }
}
```

This makes the JSON **self-documenting** - no external guide needed!

---

## Layer Structure

Each layer contains three fields:

| Field | Type | Description |
|-------|------|-------------|
| `layer_type` | string | Layer type: "Floor", "Underground", "Sky", "Height", "Difficulty", "Hazard" |
| `palette` | string[] | Array of hex color codes used in this layer |
| `color_data` | [int, int][] | RLE compressed data as [paletteIndex, count] pairs |

---

## Reading RLE Color Data

### Step-by-Step Decoding

1. **Get the palette** - This is an array of colors used in the layer
2. **Read color_data** - This is an array of `[paletteIndex, count]` pairs
3. **Decompress** - Each pair means "use color at palette[paletteIndex] for count tiles"

### Example

```json
{
  "layer_type": "Floor",
  "palette": ["#ff6b6b", "#f7dc6f", "#4ecdc4"],
  "color_data": [[0, 1000], [1, 500], [2, 100]]
}
```

**Decoding:**
- `[0, 1000]` → Use palette[0] = `#ff6b6b` for 1,000 tiles
- `[1, 500]` → Use palette[1] = `#f7dc6f` for 500 tiles
- `[2, 100]` → Use palette[2] = `#4ecdc4` for 100 tiles

**Total tiles:** 1,000 + 500 + 100 = 1,600 tiles

### Tile Ordering

Tiles are stored in **row-major order** (left-to-right, top-to-bottom):

```
Index:  0    1    2    3  ...
Coord: (0,0)(1,0)(2,0)(3,0)...
       (0,1)(1,1)(2,1)(3,1)...
```

**Formula:**
- `index = y * world_size + x`
- `x = index % world_size`
- `y = floor(index / world_size)`

### Full Decoding Algorithm

```python
def decode_layer(layer, world_size):
    palette = layer["palette"]
    color_data = layer["color_data"]

    # Create empty grid
    grid = []

    # Decompress RLE data
    for palette_index, count in color_data:
        color = palette[palette_index]
        for _ in range(count):
            grid.append(color)

    # Convert to 2D grid (optional)
    grid_2d = []
    for y in range(world_size):
        row = []
        for x in range(world_size):
            index = y * world_size + x
            row.append(grid[index])
        grid_2d.append(row)

    return grid_2d
```

---

## Complete Color Mappings

### Biome Colors (for Floor, Sky, Underground layers)

| Color | Enum Value | Name | Description |
|-------|------------|------|-------------|
| `#000000` | 0 | Biome_None | Empty/unassigned tile |
| `#ff6b6b` | 1 | Biome_ShowFloor | Store showroom floor |
| `#f7dc6f` | 2 | Biome_Restaurant | Food court/restaurant area |
| `#4ecdc4` | 3 | Biome_Warehouse | Storage/loading dock |
| `#1e3a8a` | 4 | Biome_SCPBase | SCP Foundation base (safe zone) |
| `#3b82f6` | 5 | Biome_SCPBaseEntrance | Entry point to SCP base |
| `#f59e0b` | 6 | Biome_Map | Map kiosk location |
| `#bb8fce` | 7 | Biome_HelpPoint | Player assistance location |
| `#e5d68a` | 8 | Biome_Backrooms | Liminal space areas |
| `#10b981` | 9 | Biome_SCPBaseExit | Exit from SCP base |
| `#0ea5e9` | 10 | Biome_SCPBasePower | Power room in SCP base |
| `#8b4513` | 11 | Biome_AbandonedCamp | Previous survivor camp |
| `#ff69b4` | 12 | Biome_Kids | Children's store/play area |
| `#22c55e` | 13 | Biome_Gardening | Garden center |
| `#d3d3d3` | 14 | Biome_SkyEmpty | Empty sky/void tiles |
| `#87ceeb` | 15 | Biome_SkyCeiling | Ceiling tiles (skybox) |
| `#aed6f1` | 16 | Biome_Bathroom | Restroom facilities |
| `#4a4a4a` | 17 | Biome_CarPark | Parking garage |
| `#6b7280` | 18 | Biome_CarParkEntrance | Parking entrance/ramp |
| `#9ca3af` | 19 | Biome_CarParkExit | Parking exit/ramp |
| `#deb887` | 20 | Biome_StaffRoom | Employee break room |
| `#2f2f2f` | 21 | Biome_Blocked | Permanently blocked tile |
| `#2f1b0c` | 22 | Biome_Pit | Dangerous pit/hole |

### Height Colors (for Height layer)

Height works exactly like biomes - using palette indices 0-9 for 10 different height levels.

| Color | Enum Value | Name | Description |
|-------|------------|------|-------------|
| `#0a0a0a` | 0 | Height_Underground_Deep | Deep underground |
| `#1a1a2e` | 1 | Height_Underground | Underground level |
| `#525d6b` | 2 | Height_Ground | Ground floor |
| `#778994` | 3 | Height_Ground_Mid | Mid ground level |
| `#9db5bd` | 4 | Height_Elevated | Elevated platform |
| `#b0cbd1` | 5 | Height_Elevated_Mid | Mid elevated level |
| `#c3e1e6` | 6 | Height_Upper | Upper floor |
| `#d6f5fa` | 7 | Height_Upper_High | High upper level |
| `#ffffff` | 8 | Height_Max | Maximum height |
| `#f0f0f0` | 9 | Height_Sky | Sky/ceiling level |

### Difficulty Colors (for Difficulty layer)

| Color | Enum Value | Name | Description |
|-------|------------|------|-------------|
| `#90ee90` | 0 | Difficulty_Easy | Low enemy density, weaker enemies |
| `#ffd700` | 1 | Difficulty_Normal | Moderate enemy presence |
| `#ff8c00` | 2 | Difficulty_Hard | High enemy density, stronger enemies |
| `#ff6347` | 3 | Difficulty_Nightmare | Very dangerous, elite enemies |
| `#8b0000` | 4 | Difficulty_Apocalypse | Maximum difficulty, overwhelming enemies |

### Hazard Colors (for Hazard layer)

| Color | Enum Value | Name | Description |
|-------|------------|------|-------------|
| `#1a1a1a` | 0 | Hazard_None | No environmental hazard |
| `#39ff14` | 1 | Hazard_Radiation | Gradual radiation damage |
| `#87ceeb` | 2 | Hazard_Freezing | Cold damage, slows movement |

---

## Layer Types Explained

### 1. Floor Layer (Main Ground Level)
- **Type:** `"Floor"`
- **Colors:** Biome colors (see Biome Colors table)
- **Purpose:** Primary gameplay area, store layout
- **Common biomes:** ShowFloor, Restaurant, Warehouse, etc.

### 2. Underground Layer (Basement/Parking)
- **Type:** `"Underground"`
- **Colors:** Biome colors (see Biome Colors table)
- **Purpose:** Areas below the main floor
- **Common biomes:** CarPark, CarParkEntrance, Warehouse, etc.

### 3. Sky Layer (Ceiling/Upper)
- **Type:** `"Sky"`
- **Colors:** Biome colors (see Biome Colors table)
- **Purpose:** Ceiling decorations, skybox
- **Common biomes:** SkyCeiling, SkyEmpty, Bathroom (skylights)

### 4. Height Layer (Elevation)
- **Type:** `"Height"`
- **Colors:** Height values (0-255 in red channel)
- **Purpose:** Vertical elevation data
- **Usage:** Determines floor height, ramps, stairs

### 5. Difficulty Layer (Enemy Spawns)
- **Type:** `"Difficulty"`
- **Colors:** Difficulty levels (Easy to Apocalypse)
- **Purpose:** Enemy difficulty zones
- **Usage:** Controls enemy spawn rates and strength

### 6. Hazard Layer (Environmental Damage)
- **Type:** `"Hazard"`
- **Colors:** Hazard types (None, Radiation, Freezing)
- **Purpose:** Environmental damage zones
- **Usage:** Player takes damage in these areas

---

## Reading Your Example File

Using your `TestStore (1).json`:

```json
{
  "metadata": {
    "name": "TestStore",
    "world_size": 256
  },
  "layers": [
    {"layer_type": "Height", "palette": ["#0a0a0a"], "color_data": [[0,65536]]},
    {"layer_type": "Difficulty", "palette": ["#90ee90"], "color_data": [[0,65536]]},
    {"layer_type": "Hazard", "palette": ["#1a1a1a"], "color_data": [[0,65536]]},
    {"layer_type": "Sky", "palette": ["#aed6f1"], "color_data": [[0,65536]]},
    {"layer_type": "Floor", "palette": ["#ff6b6b"], "color_data": [[0,65536]]},
    {"layer_type": "Underground", "palette": ["#6b7280"], "color_data": [[0,65536]]}
  ]
}
```

### Interpretation:

**Grid:** 256×256 = 65,536 tiles

**Height Layer:**
- Color: `#0a0a0a` (palette[0])
- Count: 65,536 tiles (entire grid)
- Meaning: **All tiles at Height_Underground_Deep (level 0)**

**Difficulty Layer:**
- Color: `#90ee90` (palette[0])
- Count: 65,536 tiles
- Meaning: **All tiles are Difficulty_Easy** (value 0)

**Hazard Layer:**
- Color: `#1a1a1a` (palette[0])
- Count: 65,536 tiles
- Meaning: **All tiles are Hazard_None** (value 0)

**Sky Layer:**
- Color: `#aed6f1` (palette[0])
- Count: 65,536 tiles
- Meaning: **All sky tiles are Biome_Bathroom** (value 16)

**Floor Layer:**
- Color: `#ff6b6b` (palette[0])
- Count: 65,536 tiles
- Meaning: **All floor tiles are Biome_ShowFloor** (value 1)

**Underground Layer:**
- Color: `#6b7280` (palette[0])
- Count: 65,536 tiles
- Meaning: **All underground tiles are Biome_CarParkEntrance** (value 18)

---

## Complete Python Reader Example

```python
import json

# Color-to-biome mappings
BIOME_MAP = {
    "#000000": {"value": 0, "name": "None"},
    "#ff6b6b": {"value": 1, "name": "ShowFloor"},
    "#f7dc6f": {"value": 2, "name": "Restaurant"},
    "#4ecdc4": {"value": 3, "name": "Warehouse"},
    "#1e3a8a": {"value": 4, "name": "SCPBase"},
    "#3b82f6": {"value": 5, "name": "SCPBaseEntrance"},
    "#f59e0b": {"value": 6, "name": "Map"},
    "#bb8fce": {"value": 7, "name": "HelpPoint"},
    "#e5d68a": {"value": 8, "name": "Backrooms"},
    "#10b981": {"value": 9, "name": "SCPBaseExit"},
    "#0ea5e9": {"value": 10, "name": "SCPBasePower"},
    "#8b4513": {"value": 11, "name": "AbandonedCamp"},
    "#ff69b4": {"value": 12, "name": "Kids"},
    "#22c55e": {"value": 13, "name": "Gardening"},
    "#d3d3d3": {"value": 14, "name": "SkyEmpty"},
    "#87ceeb": {"value": 15, "name": "SkyCeiling"},
    "#aed6f1": {"value": 16, "name": "Bathroom"},
    "#4a4a4a": {"value": 17, "name": "CarPark"},
    "#6b7280": {"value": 18, "name": "CarParkEntrance"},
    "#9ca3af": {"value": 19, "name": "CarParkExit"},
    "#deb887": {"value": 20, "name": "StaffRoom"},
    "#2f2f2f": {"value": 21, "name": "Blocked"},
    "#2f1b0c": {"value": 22, "name": "Pit"}
}

DIFFICULTY_MAP = {
    "#90ee90": {"value": 0, "name": "Easy"},
    "#ffd700": {"value": 1, "name": "Normal"},
    "#ff8c00": {"value": 2, "name": "Hard"},
    "#ff6347": {"value": 3, "name": "Nightmare"},
    "#8b0000": {"value": 4, "name": "Apocalypse"}
}

HAZARD_MAP = {
    "#1a1a1a": {"value": 0, "name": "None"},
    "#39ff14": {"value": 1, "name": "Radiation"},
    "#87ceeb": {"value": 2, "name": "Freezing"}
}

HEIGHT_MAP = {
    "#0a0a0a": {"value": 0, "name": "Underground_Deep"},
    "#1a1a2e": {"value": 1, "name": "Underground"},
    "#525d6b": {"value": 2, "name": "Ground"},
    "#778994": {"value": 3, "name": "Ground_Mid"},
    "#9db5bd": {"value": 4, "name": "Elevated"},
    "#b0cbd1": {"value": 5, "name": "Elevated_Mid"},
    "#c3e1e6": {"value": 6, "name": "Upper"},
    "#d6f5fa": {"value": 7, "name": "Upper_High"},
    "#ffffff": {"value": 8, "name": "Max"},
    "#f0f0f0": {"value": 9, "name": "Sky"}
}

def decode_layer(layer_data, world_size):
    """Decode RLE layer data into flat array"""
    palette = layer_data["palette"]
    color_data = layer_data["color_data"]

    tiles = []
    for palette_index, count in color_data:
        color = palette[palette_index].lower()
        tiles.extend([color] * count)

    return tiles

def parse_level(json_path):
    """Parse complete level JSON file"""
    with open(json_path, 'r') as f:
        data = json.load(f)

    metadata = data["metadata"]
    world_size = metadata["world_size"]

    print(f"Level: {metadata['name']}")
    print(f"Size: {world_size}×{world_size} ({world_size * world_size} tiles)")
    print()

    layers = {}

    for layer_data in data["layers"]:
        layer_type = layer_data["layer_type"]
        tiles = decode_layer(layer_data, world_size)
        layers[layer_type] = tiles

        # Analyze layer
        unique_colors = set(tiles)
        print(f"\n{layer_type} Layer:")
        print(f"  Unique colors: {len(unique_colors)}")

        for color in unique_colors:
            count = tiles.count(color)
            percentage = (count / len(tiles)) * 100

            # Lookup what this color means
            if layer_type in ["Floor", "Underground", "Sky"]:
                mapping = BIOME_MAP.get(color.lower(), {"name": "Unknown"})
                print(f"  {color}: {mapping['name']} ({count} tiles, {percentage:.1f}%)")
            elif layer_type == "Height":
                mapping = HEIGHT_MAP.get(color.lower(), {"name": "Unknown"})
                print(f"  {color}: {mapping['name']} ({count} tiles, {percentage:.1f}%)")
            elif layer_type == "Difficulty":
                mapping = DIFFICULTY_MAP.get(color.lower(), {"name": "Unknown"})
                print(f"  {color}: {mapping['name']} ({count} tiles, {percentage:.1f}%)")
            elif layer_type == "Hazard":
                mapping = HAZARD_MAP.get(color.lower(), {"name": "Unknown"})
                print(f"  {color}: {mapping['name']} ({count} tiles, {percentage:.1f}%)")

    return {
        "metadata": metadata,
        "world_size": world_size,
        "layers": layers
    }

# Example usage
level = parse_level("TestStore (1).json")

# Access specific tile
world_size = level["world_size"]
x, y = 10, 20
index = y * world_size + x

floor_color = level["layers"]["Floor"][index]
biome = BIOME_MAP.get(floor_color.lower(), {"name": "Unknown"})
print(f"\nTile at ({x}, {y}): {biome['name']}")
```

---

## JavaScript Reader Example

```javascript
const BIOME_MAP = {
    "#000000": { value: 0, name: "None" },
    "#ff6b6b": { value: 1, name: "ShowFloor" },
    "#aed6f1": { value: 16, name: "Bathroom" },
    "#6b7280": { value: 18, name: "CarParkEntrance" }
    // ... add rest of mappings
};

function decodeLayer(layerData, worldSize) {
    const palette = layerData.palette;
    const colorData = layerData.color_data;

    const tiles = [];
    for (const [paletteIndex, count] of colorData) {
        const color = palette[paletteIndex].toLowerCase();
        for (let i = 0; i < count; i++) {
            tiles.push(color);
        }
    }

    return tiles;
}

function parseLevel(jsonData) {
    const metadata = jsonData.metadata;
    const worldSize = metadata.world_size;

    const layers = {};

    for (const layerData of jsonData.layers) {
        const layerType = layerData.layer_type;
        const tiles = decodeLayer(layerData, worldSize);
        layers[layerType] = tiles;
    }

    return { metadata, worldSize, layers };
}

// Get tile at specific coordinate
function getTile(layers, layerType, x, y, worldSize) {
    const index = y * worldSize + x;
    const color = layers[layerType][index];
    return BIOME_MAP[color] || { name: "Unknown" };
}

// Usage
fetch("TestStore (1).json")
    .then(res => res.json())
    .then(data => {
        const level = parseLevel(data);
        const tile = getTile(level.layers, "Floor", 10, 20, level.worldSize);
        console.log("Tile at (10, 20):", tile.name);
    });
```

---

## C# Reader Example (for Unreal Engine)

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using Newtonsoft.Json;

[System.Serializable]
public class LevelMetadata {
    public string name;
    public string description;
    public int world_size;
    public long maze_generation_seed;
}

[System.Serializable]
public class LayerData {
    public string layer_type;
    public string[] palette;
    public int[][] color_data; // [paletteIndex, count] pairs
}

[System.Serializable]
public class LevelFile {
    public LevelMetadata metadata;
    public LayerData[] layers;
}

public class LevelReader {
    private static Dictionary<string, int> BiomeMap = new Dictionary<string, int> {
        { "#000000", 0 },  // None
        { "#ff6b6b", 1 },  // ShowFloor
        { "#aed6f1", 16 }, // Bathroom
        { "#6b7280", 18 }, // CarParkEntrance
        // ... add rest of 23 biomes
    };

    private static Dictionary<string, int> HeightMap = new Dictionary<string, int> {
        { "#0a0a0a", 0 },  // Underground_Deep
        { "#1a1a2e", 1 },  // Underground
        { "#525d6b", 2 },  // Ground
        { "#778994", 3 },  // Ground_Mid
        { "#9db5bd", 4 },  // Elevated
        { "#b0cbd1", 5 },  // Elevated_Mid
        { "#c3e1e6", 6 },  // Upper
        { "#d6f5fa", 7 },  // Upper_High
        { "#ffffff", 8 },  // Max
        { "#f0f0f0", 9 }   // Sky
    };

    private static Dictionary<string, int> DifficultyMap = new Dictionary<string, int> {
        { "#90ee90", 0 },  // Easy
        { "#ffd700", 1 },  // Normal
        { "#ff8c00", 2 },  // Hard
        { "#ff6347", 3 },  // Nightmare
        { "#8b0000", 4 }   // Apocalypse
    };

    private static Dictionary<string, int> HazardMap = new Dictionary<string, int> {
        { "#1a1a1a", 0 },  // None
        { "#39ff14", 1 },  // Radiation
        { "#87ceeb", 2 }   // Freezing
    };

    public static string[] DecodeLayer(LayerData layer) {
        List<string> tiles = new List<string>();

        foreach (var entry in layer.color_data) {
            int paletteIndex = entry[0];
            int count = entry[1];
            string color = layer.palette[paletteIndex].ToLower();

            for (int i = 0; i < count; i++) {
                tiles.Add(color);
            }
        }

        return tiles.ToArray();
    }

    public static LevelFile LoadLevel(string jsonPath) {
        string json = File.ReadAllText(jsonPath);
        return JsonConvert.DeserializeObject<LevelFile>(json);
    }
}

// Usage in Unreal Engine
public class WorldGenerator : MonoBehaviour {
    void LoadWorld(string jsonPath) {
        LevelFile level = LevelReader.LoadLevel(jsonPath);
        int worldSize = level.metadata.world_size;

        foreach (var layerData in level.layers) {
            string[] tiles = LevelReader.DecodeLayer(layerData);

            // Spawn tiles based on layer type
            for (int y = 0; y < worldSize; y++) {
                for (int x = 0; x < worldSize; x++) {
                    int index = y * worldSize + x;
                    string color = tiles[index].ToLower();

                    switch (layerData.layer_type) {
                        case "Floor":
                        case "Underground":
                        case "Sky":
                            int biomeValue = LevelReader.BiomeMap[color];
                            SpawnBiomeTile(x, y, biomeValue, layerData.layer_type);
                            break;
                        case "Height":
                            int heightValue = LevelReader.HeightMap[color];
                            SetTileHeight(x, y, heightValue);
                            break;
                        case "Difficulty":
                            int difficultyValue = LevelReader.DifficultyMap[color];
                            SetTileDifficulty(x, y, difficultyValue);
                            break;
                        case "Hazard":
                            int hazardValue = LevelReader.HazardMap[color];
                            SetTileHazard(x, y, hazardValue);
                            break;
                    }
                }
            }
        }
    }
}
```

---

## Common Issues & Solutions

### Issue 1: "All tiles are the same color"
**Solution:** This is normal if you painted the entire layer with one biome. Not an error!

### Issue 2: "Color not found in mapping"
**Solution:** Colors are case-insensitive. Convert to lowercase before lookup:
```python
color = color.lower()
```

### Issue 3: "Wrong number of tiles"
**Solution:** Verify that sum of all counts equals `world_size * world_size`:
```python
total_tiles = sum(count for _, count in layer["color_data"])
assert total_tiles == world_size * world_size
```

### Issue 4: "Height/Difficulty/Hazard enum not found"
**Solution:** Make sure you have lookup tables for ALL layer types, not just biomes. Each layer type uses palette indices to map to enum values 0-N.

---

## Summary

**ALL layers work the same way** - using simple palette indices (0-N) to reference enum values:

1. **Parse JSON** → Get metadata and layers
2. **For each layer** → Get palette and color_data
3. **Decompress RLE** → Expand [paletteIndex, count] pairs into flat array
4. **Map colors** → Use lookup tables to convert colors to enum values:
   - **Biomes**: 23 values (0-22)
   - **Heights**: 10 values (0-9)
   - **Difficulty**: 5 values (0-4)
   - **Hazards**: 3 values (0-2)
5. **Generate world** → Place tiles in row-major order (left-to-right, top-to-bottom)

**Key Formula:**
```
index = y * world_size + x
color = tiles[index]
enum_value = COLOR_MAP[color]
```

**Important:** Don't try to extract values from color channels! Each color maps to a simple enum index. The colors are just visual identifiers.

This format is **compact, efficient, and lossless** - perfect for large procedural worlds!
