# How to Read TSIC Level Editor JSON Files

## Quick Summary

The JSON file has **4 main sections**:
1. **metadata** - Basic info about the level
2. **layers** - The actual tile data (compressed with RLE)
3. **color_mappings** - Dictionary to convert colors to game enum values
4. **format_info** - Instructions on how to read (you're reading an expanded version now)

---

## Step-by-Step Reading Guide

### Step 1: Parse the JSON

Load the JSON file. You'll get an object with 4 keys: `metadata`, `layers`, `color_mappings`, and `format_info`.

```javascript
const data = JSON.parse(fileContents);
```

---

### Step 2: Read the Metadata

```json
{
  "metadata": {
    "name": "test3",
    "description": "Generated by TSIC Level Editor",
    "world_size": 512,
    "maze_generation_seed": 1762353161421
  }
}
```

**What you need:**
- `world_size`: The grid is ALWAYS square. A `512` means 512×512 = 262,144 tiles total.

---

### Step 3: Understand the Layers Array

```json
{
  "layers": [
    {
      "layer_type": "Height",
      "palette": ["#0a0a0a"],
      "color_data": [[0, 262144]]
    },
    {
      "layer_type": "Floor",
      "palette": ["#ff6b6b", "#f7dc6f"],
      "color_data": [[0, 100000], [1, 162144]]
    }
  ]
}
```

Each layer has:
- **layer_type**: "Height", "Floor", "Underground", "Sky", "Difficulty", or "Hazard"
- **palette**: Array of hex colors used in this layer
- **color_data**: RLE compressed tile data (explained below)

---

### Step 4: Decode the RLE Data

**RLE = Run-Length Encoding**

Format: `[[paletteIndex, count], [paletteIndex, count], ...]`

**What it means:**
- `[0, 100000]` = Use color at `palette[0]` for 100,000 tiles
- `[1, 162144]` = Use color at `palette[1]` for 162,144 tiles

**Example:**
```json
{
  "palette": ["#ff6b6b", "#f7dc6f"],
  "color_data": [[0, 100000], [1, 162144]]
}
```

Decompresses to:
```
Tile 0-99999: color = palette[0] = "#ff6b6b"
Tile 100000-262143: color = palette[1] = "#f7dc6f"
```

**Decompression Algorithm (pseudocode):**
```python
def decode_layer(palette, color_data):
    tiles = []
    for [palette_index, count] in color_data:
        color = palette[palette_index]
        for i in range(count):
            tiles.append(color)
    return tiles
```

---

### Step 5: Convert Tile Index to X,Y Coordinates

Tiles are stored in **row-major order** (left-to-right, top-to-bottom):

```
Index:  0    1    2    3  ...
Coord: (0,0)(1,0)(2,0)(3,0)...
       (0,1)(1,1)(2,1)(3,1)...
```

**Formulas:**
```python
# Index to X,Y
x = index % world_size
y = index // world_size

# X,Y to index
index = y * world_size + x
```

**Example:** World size = 512
- Index 0 → (x=0, y=0)
- Index 512 → (x=0, y=1)
- Index 513 → (x=1, y=1)

---

### Step 6: Convert Colors to Enum Values

Use the `color_mappings` section to look up what each color means:

```json
{
  "color_mappings": {
    "biomes": {
      "#ff6b6b": {
        "value": 1,
        "name": "Biome_ShowFloor",
        "description": "Store showroom floor"
      }
    },
    "heights": {
      "#0a0a0a": {
        "value": 0,
        "name": "Height_0",
        "description": "Height level 0"
      }
    }
  }
}
```

**Which category to use:**
- **Floor, Underground, Sky layers** → use `color_mappings.biomes`
- **Height layer** → use `color_mappings.heights`
- **Difficulty layer** → use `color_mappings.difficulty`
- **Hazard layer** → use `color_mappings.hazards`

**Example:**
```python
# Floor layer with color "#ff6b6b"
layer_type = "Floor"
color = "#ff6b6b"

# Look up in biomes
mapping = color_mappings["biomes"][color]
enum_value = mapping["value"]  # = 1
enum_name = mapping["name"]    # = "Biome_ShowFloor"
```

---

## Complete Example: Reading a Layer

Let's read the Floor layer from test3.json:

```json
{
  "layer_type": "Floor",
  "palette": ["#ff6b6b"],
  "color_data": [[0, 262144]]
}
```

**Step 1:** Decode RLE
```python
palette = ["#ff6b6b"]
color_data = [[0, 262144]]

tiles = []
for [palette_index, count] in color_data:
    color = palette[palette_index]  # palette[0] = "#ff6b6b"
    for i in range(count):          # 262144 times
        tiles.append(color)

# Result: 262,144 tiles all with color "#ff6b6b"
```

**Step 2:** Get tile at position (10, 20)
```python
world_size = 512
x, y = 10, 20
index = y * world_size + x  # 20 * 512 + 10 = 10250
color = tiles[index]         # "#ff6b6b"
```

**Step 3:** Convert color to enum
```python
layer_type = "Floor"  # Floor uses biomes category
mapping = color_mappings["biomes"]["#ff6b6b"]

enum_value = mapping["value"]  # 1
enum_name = mapping["name"]    # "Biome_ShowFloor"
```

**Result:** Tile at (10, 20) is **Biome_ShowFloor** (enum value 1)

---

## All Enum Ranges

The `color_mappings` section contains all possible values:

| Category | Count | Range | Used By Layers |
|----------|-------|-------|----------------|
| biomes | 23 | 0-22 | Floor, Underground, Sky |
| heights | 10 | 0-9 | Height |
| difficulty | 5 | 0-4 | Difficulty |
| hazards | 3 | 0-2 | Hazard |

**Total:** 41 different color-to-enum mappings included in every export.

---

## Complete Python Implementation

```python
import json

def read_tsic_level(json_path):
    # Load JSON
    with open(json_path, 'r') as f:
        data = json.load(f)

    world_size = data['metadata']['world_size']
    color_mappings = data['color_mappings']

    # Process each layer
    world = {}
    for layer_data in data['layers']:
        layer_type = layer_data['layer_type']

        # Decode RLE
        tiles = []
        for palette_index, count in layer_data['color_data']:
            color = layer_data['palette'][palette_index].lower()
            tiles.extend([color] * count)

        # Store layer
        world[layer_type] = tiles

    return world, world_size, color_mappings

def get_tile(world, layer_type, x, y, world_size, color_mappings):
    # Get color at position
    index = y * world_size + x
    color = world[layer_type][index]

    # Get category based on layer type
    if layer_type in ['Floor', 'Underground', 'Sky']:
        category = 'biomes'
    elif layer_type == 'Height':
        category = 'heights'
    elif layer_type == 'Difficulty':
        category = 'difficulty'
    elif layer_type == 'Hazard':
        category = 'hazards'

    # Look up enum
    mapping = color_mappings[category][color]
    return mapping['value'], mapping['name']

# Usage
world, world_size, mappings = read_tsic_level('test3.json')

# Get Floor tile at position (10, 20)
value, name = get_tile(world, 'Floor', 10, 20, world_size, mappings)
print(f"Floor at (10, 20): {name} (value: {value})")
```

---

## Complete JavaScript Implementation

```javascript
function readTSICLevel(jsonData) {
    const worldSize = jsonData.metadata.world_size;
    const colorMappings = jsonData.color_mappings;

    // Process each layer
    const world = {};
    for (const layerData of jsonData.layers) {
        const layerType = layerData.layer_type;

        // Decode RLE
        const tiles = [];
        for (const [paletteIndex, count] of layerData.color_data) {
            const color = layerData.palette[paletteIndex].toLowerCase();
            for (let i = 0; i < count; i++) {
                tiles.push(color);
            }
        }

        world[layerType] = tiles;
    }

    return { world, worldSize, colorMappings };
}

function getTile(world, layerType, x, y, worldSize, colorMappings) {
    // Get color at position
    const index = y * worldSize + x;
    const color = world[layerType][index];

    // Get category based on layer type
    let category;
    if (['Floor', 'Underground', 'Sky'].includes(layerType)) {
        category = 'biomes';
    } else if (layerType === 'Height') {
        category = 'heights';
    } else if (layerType === 'Difficulty') {
        category = 'difficulty';
    } else if (layerType === 'Hazard') {
        category = 'hazards';
    }

    // Look up enum
    const mapping = colorMappings[category][color];
    return { value: mapping.value, name: mapping.name };
}

// Usage
const jsonData = JSON.parse(fileContents);
const { world, worldSize, colorMappings } = readTSICLevel(jsonData);

// Get Floor tile at position (10, 20)
const tile = getTile(world, 'Floor', 10, 20, worldSize, colorMappings);
console.log(`Floor at (10, 20): ${tile.name} (value: ${tile.value})`);
```

---

## Common Mistakes to Avoid

### ❌ Wrong: Trying to extract from color channels
```python
# DON'T DO THIS!
red = int(color[1:3], 16)  # WRONG
height = red  # WRONG
```

### ✅ Correct: Use color lookup
```python
# DO THIS!
mapping = color_mappings['heights'][color]
height = mapping['value']  # CORRECT
```

### ❌ Wrong: Forgetting RLE decompression
```python
# DON'T DO THIS!
color = palette[color_data[0][0]]  # Only gets first color
```

### ✅ Correct: Decompress all runs
```python
# DO THIS!
tiles = []
for palette_index, count in color_data:
    color = palette[palette_index]
    tiles.extend([color] * count)
```

### ❌ Wrong: Using wrong category for lookup
```python
# DON'T DO THIS!
mapping = color_mappings['biomes'][color]  # Wrong for Height layer
```

### ✅ Correct: Match layer type to category
```python
# DO THIS!
if layer_type == 'Height':
    mapping = color_mappings['heights'][color]
elif layer_type in ['Floor', 'Underground', 'Sky']:
    mapping = color_mappings['biomes'][color]
```

---

## Validation Checklist

After implementing your reader, verify:

✅ Total tiles = `world_size * world_size`
✅ All RLE runs sum to correct total
✅ Colors are case-insensitive (lowercase recommended)
✅ X,Y coordinates match row-major order
✅ Using correct color_mappings category for each layer type
✅ All 6 layers present: Height, Difficulty, Hazard, Sky, Floor, Underground

---

## Summary

1. **Load JSON** - 4 sections: metadata, layers, color_mappings, format_info
2. **Read world_size** - Grid dimensions (always square)
3. **Decode RLE** - Expand `[[index, count], ...]` to flat color array
4. **Convert index to X,Y** - Use `x = index % world_size`, `y = index // world_size`
5. **Look up enum** - Use `color_mappings[category][color]` to get value
6. **Match layer to category** - Floor/Underground/Sky=biomes, Height=heights, etc.

The JSON is **self-contained** - everything you need is in the file. No external files or lookups required!
